### 知识总览

* 进程
  * 定义
    * 在计算机发展史上，"进程"是为了解决什么问题而被引入的？
  * 组成
    * 每个进程由哪些部分组成？
  * 组织方式
    * 系统中各个进程之间是如何被组织起来的？
  * 特征
    * 相比于程序，进程有哪些特征？

---

### 进程的定义

* 单道程序技术
  * 程序:就是一个指令序列
  * 内存
    * 程序段
      * 程序代码
    * 数据段
      * 程序的代码放在程序段内，程序运行过程处理的数据放在数据段内\(如变量\)
* 多道程序技术
  * 内存:可以存放多个程序段和数据段
  * 为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念
  * 系统为每个运行的程序配置一个数据结构，称为进程控制块\(PCB\)，用来描述进程的各种信息\(如程序代码存放位置\)
  * PCB、程序段、数据段三部分构成了进程实体\(进程映象\)
    * 一般情况下，把进程实体简称为进程
    * 例如。所谓创建进程，实质上就是创建进程实体中的PCB；而撤销进程，实质上是撤销进程实体中的PCB
    * PCB是进程存在的唯一标志
    * 进程定义:进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
      * 严格来说，进程实体和进程是不一样的，进程实体是静态的，进程则是动态的

```
从不同的角度，进程可以有不同的定义，比较传统典型的定义有:
1.进程是程序的一次执行过程
2.进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3.进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位

* 强调动态性
```

* 进程的组成
  * 进程\(进程实体\)由程序段、数据段、PCB三部分组成
    * 程序段:程序代码
    * 数据段:程序运行时使用，产生的运算数据
    * PCB:操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需1的各种信息
  * PCB
    * 进程描述信息
      * 进程标识符PID
        * 当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程\(类似于身份证号\)
      * 用户标识符UID
    * 进程控制和管理信息
      * 进程当前状态
      * 进程优先级
    * 资源分配清单
      * 程序段指针
      * 数据段指针
      * 键盘
      * 鼠标
    * 处理机相关信息
      * 各种寄存器值
        * 当进程切换时需要把进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句

---

* 进程的组成

  * PDB:进程的管理者\(操作系统所需的数据都在PCB中\)
    * 进程描述信息
    * 进程控制和管理信息
    * 资源分配清单
    * 处理机相关信息
  * 程序段

    * 存放要执行的代码

    ```
    程序段-数据段 --> 程序本身的运行所需的数据
    ```

  * 数据段

    * 存放程序运行过程中处理的各种数据

---

* 进程的组织
  * 链接方式
    * 按照进程状态将PCB分为多个队列
    * 操作系统持有指向各个队列的指针
  * 索引方式
    * 根据进程状态的不同，建立几张索引表
    * 操作系统持有指向各个索引表的指针

### 链接方式

* 执行指针
* 就绪队列指针
* 阻塞队列指针

### 索引方式

* 执行指针
* 就绪表指针
* 阻塞表指针

---

* 进程的特征:动态性进程的最基本的特征
  * 动态性
    * 进程是程序的一次执行过程，是动态地产生、变化和消亡的
  * 并发性
    * 内存中有多个进程实体，各进程可并发执行
  * 独立性
    * 进程是能独立运行、独立获得资源、独立接收调度的基本单位
  * 异步性
    * 各进程按各自独立的、不可预知的速度向前推进，操作系统要提供"进程同步机制"来解决异步问题
      * 异步性会导致并发程序执行结构的不确定性
  * 结构性
    * 每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成

---

### 知识点总结

* 进程

  * 定义
    * 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
  * 组成

    * PCB:PCB是进程存在的唯一标志
      * 进程描述信息
      * 进程控制和管理信息:进程的管理者\(操作系统\)所需的数据都在PCB中
      * 资源分配清单
      * 处理机相关信息
    * 程序段:程序本身的运行所需的数据在程序段、数据段中

      * 存储要执行的程序代码

    * 数据段

      * 存放程序运行过程中处理的各种数据

  * 组织形式

    * 链接方式
      * 按进程状态将PCB分为多个队列
    * 索引方式
      * 按照进程状态建立几张索引表，各表项指向一个PCB

  * 特征

    * 动态性
      * 进程的最基本特征
    * 并发性
    * 独立性
      * 进程是系统进行资源分配、调度的独立单位
    * 异步性
      * 各进程以不可预知的速度向前推进，可能导致运行结构不确定性
    * 结构性

---

### 进程的状态和转换

* 状态
  * 运行状态
  * 就绪状态
  * 阻塞状态
  * 创建状态
  * 终止状态
* 进程状态间的转换
  * 就绪态 -&gt; 运行态
  * 运行态 -&gt; 阻塞态
  * 运行态 -&gt; 阻塞态
  * 阻塞态 -&gt; 就绪态

#### 三种基本状态

```
进程是程序的一次执行
```

* 运行态:占有CPU，并在CPU上运行

* 就绪态:已经具备运行条件，但由于没有空闲CPU，而暂时不能运行

* 阻塞态\(等待态\):因等待某一事件而暂时不能运行

#### 另外两种状态

* 创建态\(新建态\):进程正在被创建，操作系统为进程分配资源、初始化PCB
* 终止态\(结束态\):进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

#### 进程状态的转换

![](/assets/13.3.5-4.png)

#### 知识点总结

* 进程的状态与转换

  * 状态

    * **运行状态:需要CPU和其他所需资源**
    * **就绪状态:不需要CPU但需要其他所需资源**

    * **阻塞状态:不需要CPU和其他所需资源**

    * 创建状态:操作系统为新进程分配资源、创建PCB

    * 终止状态:操作系统回收进程的资源、撤销PCB

  * 进程状态间的转换

    * **就绪态-&gt;运行态:进程调度**
    * **运行态-&gt;就绪态:时间片到，或CPU被其他高优先级的进程强占**
    * **运行态-&gt;阻塞态:等待系统资源分配，或等待某事件发生\(主动行为\)**
    * **阻塞态-&gt;就绪态:资源分配到位，等待的事件发生\(被动行为\)**
    * 创建态-&gt;就绪态:系统完成创建进程相关的工作
    * 运行态-&gt;终止态:进程运行结束，或运行过程中遇到不可修复的错误

---

### 进程控制

* 基本概念
  * 什么是进程控制?
    * 进程的控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态等功能
    * 简单理解就是:进程控制就是要实现进程状态转换
  * 如何实现进程控制?
    * 用"原语"实现
    * 1. 创建进程:需要初始化PCB、分配系统资源
      2. 创建态-&gt;就绪态需修改PCB内容和相应队列
      3. 就绪态-&gt;运行态需恢复进程运行环境、修改PCB内容和相应队列
      4. 运行态-&gt;阻塞态需保存进程运行环境、修改PCB内容和相应队列
      5. 阻塞态-&gt;就绪态需修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源
      6. 运行态-&gt;终止态需回收进程拥有的资源，撤销PCB
      7. 运行态-&gt;就绪态\(进程切换\)需保存进程运行环境、修改PCB内容和相应队列
    * 用原语实现进程控制。原语的特点是执行期间不允许中断，只能一起呵成。这种不可被中断的操作即原子操作
      * 原语采用"关中断指令"和"开中断指令"实现
* 进程控制相关的原语
  * 进程的创建
  * 进程的终止
  * 进程的阻塞
  * 进程的唤醒
  * 进程的切换
  * 1. **更新PCB中的信息**
    2. **将PCB插入合适的队列**
    3. **分配/回收资源**

### 进程的创建

* 创建原语
  * 申请空白PCB
  * 为新进程分配所需资源
  * 初始化PCB
  * 将PCB插入就绪队列
* 引起进程创建的事件
  * 用户登录:分时系统中，用户登录成功，系统会建立为其建立一个新的进程
  * 作业调度:多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
  * 提供服务:用户向操作系统提出某些请求时，会新建一个进程处理请求
  * 应用请求:由用户进程主动请求创建一个子进程

### 进程的终止

* 撤销原语
  * 从PCB集合中找到终止进程的PCB
  * 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
  * 终止其所有子进程
  * 将该进程拥有的所有资源归还父进程或操作系统
  * 删除PCB
* 引起进程终止的事件
  * 正常结束
  * 异常结束
  * 外界干预

#### 进程的唤醒

* 进程的阻塞
  * 阻塞原语:运行态-&gt;阻塞态
    * 找到要阻塞的进程对应的PCB
    * 保护进程运行现场，将PCB状态信息设置为"阻塞态"，暂时停止进程运行
    * 将PCB插入相应事件的等待队列
  * 引起进程阻塞的事件
    * 需要等待系统分配某种资源
    * 需要等待相互合作的其他进程完成工作
* 进程的唤醒
  * 唤醒原语:阻塞态-&gt;就绪态
    * 在事件等待队列找到PCB
    * 将PCB从等待队列移除，设置进程为就绪态
    * 将PCB插入就绪队列，等待被调度
  * 引起进程唤醒的事件
    * 等待的事件发生

### 进程的切换

* 切换原语
  * 将运行环境信息存入PCB
  * PCB移入相应队列
  * 选择另一个进程执行，并更新其PCB
  * 根据PCB恢复新进程所需的运行环境
* 引起进程切换的事件
  * 当前进程事件片刻
  * 有更高优先级的进程到达
  * 当前进程主动阻塞

#### 知识点

* 进程控制
  * 基本概念
    * 进程控制就是要实现进程状态的转换
    * 进程控制用原语实现
      * 原语用关/开中断来实现
      * 原语是一种特殊的程序
      * 原语的执行必须一气呵成，不可中断
  * 相关原语
    * 进程的创建
    * **进程的终止**
    * **进程的阻塞**
    * **进程的唤醒**
      * 阻塞和唤醒要成对出现
    * 进程的切换

---

### 进程通信

* 共享存储
  * 基于数据结构的共享
    * 比如共享控制里只能放一个长度为10的数组。
      * 共享方式速度慢、限制多，是一种低级通信方式
  * 基于存储区的共享
    * 在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式
      * 1. 两个进程对共享空间的访问必须是互斥的\(互斥访问通过操作系统提供的工具实现\)
        2. 操作系统只负责提供共享空间和同步互斥工具\(如P、V操作\)
* 消息传递
  * 传递方式
    * 直接通信方式
      * 其实就是把消息直接挂到接收进程的消息缓冲队列上
    * 间接通信方式
      * 消息要先发送到中间实体\(信箱\)中，因此也称为"信箱通信方式"
  * 1. 进程间的数据交换以**格式化的信息**为单位。进程通过操作系统提供的"发送消息/接收消息"两个原语进行数据交换
    2. 分为两个部分:
       1. 消息头
          1. 包括发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息\(计算机网络中发生的"报文"其实就是一种格式化的消息\)
       2. 消息体
* 管道通信
  * "管道"是指用于连续读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区
  * 1. 管道只能采用**半双工通信**，某一时间段只能实现单向的传输。如果要实现**双向同时通信，则需要设置两个管道**。
    2. 各进程要**互斥**地访问管道
    3. 如果没写满，就不允许读。如果没读空，就不运行写
    4. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况

#### 什么是进程通信？

* 进程通信指进程之间的信息交换
* 进程是分配系统资源的单位\(包括内存地址空间\)，因此各进程拥有的内存地址空间系那个户独立
* 为了保证安全，一个进程不能直接访问另一个进程的地址空间

#### 知识总结

* 进程通信
  * 共享存储
    * 设置一个共享空间
    * 要互斥地访问共享空间
    * 两种方式
      * 基于数据结构\(低级\)
      * 基于存储区的共享\(高级\)
  * 管道通信
    * 设置一个特殊的共享文件\(管道\)，其实就是一个缓冲区
    * 一个管道只能实现半双工通信
    * 实现双向同时通信要建立两个管道
    * 各进程要互斥访问管道
    * 写满时，不能在写；读空时，不能再读
    * 没写满，不能读；没读空，不能写
  * 消息传递
    * 传递结构化的消息\(消息头/消息体\)
    * 系统提供"发送/接受原语"
    * 两种方式
      * 直接通信方式
        * 消息直接挂到接收方的消息队列里
      * 简介\(信箱\)通信方式
        * 消息先发到中间实体\(信箱\)

---

### 线程概念多线程模型

* 什么是线程，为什么要引入线程?
  * 传统的进程是程序执行流的最小单位
  * 引入线程后，线程成为了程序执行流的最小单位
    * 线程是一个基本的CPU执行单元，也是程序执行流的最小单位
  * 引入进程之后，不仅是进程之间可以并发，进程内的各线程之间可以并发，从而进一步提升了系统的并发度，使得一个进程内可以并发处理各种任务
  * 引入线程后，进程只作为除CPU之外的系统资源的分配单元\(如打印机、内存地址空间等都是分配给进程的\)
* 引入线程机制后，有什么变化？
  * 带来的变化
    * 资源分配、调度
      * 传统进程机制中，进程是资源分配、调度的基本单位
      * 引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
    * 并发性
      * 传统进程机制中，只能进程间并发
      * 引入进程后，各线程间也能并发，提升了并发度
    * 系统开销
      * 传统的进程间并发，需要切换进程的运行环境，系统开销很大
      * 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
      * 引入线程后，并发所带来的系统开销小
* 线程有哪些重要的属性
  * 线程的属性
    * 线程是处理机调度的单位
    * 多CPU计算机，各个线程可占用不同的CPU
    * 每个线程都有一个线程ID、线程控制块\(TCB\)
    * 线程也有就绪、阻塞、运行三种基本状态
    * 线程几乎不拥有系统资源
    * 同一进程的不同线程间共享进程的资源
    * 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
    * 同一进程中的线程切换，不会引起进程切换
    * 切换同进程内的进程，系统开销很小
    * 不同进程间的切换，开销很大
* 线程的实现方式

  * 用户级线程
    * 用户级线程由应用程序通过线程库实现
      * 所有的线程管理工作都由应用程序负责\(包括线程切换\)
    * 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预
    * 在用户看来，是有个线程，但是在操作系统内核看，并意识不到线程的存在\(用户级线程对用户不透明，对操作系统透明\)
  * 内核级线程

    * 内核级线程的管理工作由操作系统内核完成的
    * 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成

    ```
    *** 操作系统只"看得见"内核级进程，因此只有内核级线程才是处理机分配的单位
    ```

* 多线程模型

  * 多对一模型
    * 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程
    * 优点:用户级线程的切换在用户控件即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
    * 缺点:当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行 
  * 一对一模型

    * 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程
    * 优点:当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多处理机上并行执行
    * 缺点:一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

  * 多对多模型

    * n用户及线程映射到m个内核级线程\(n&gt;=m\)。每个用户进程对应m个内核级线程
    * 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级进程，开销太大的缺点

![](/assets/13.3.4-1.png)

